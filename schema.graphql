# This file is automatically generated by Keystone, do not modify it manually.
# Modify your Keystone config when you want to change this.

type Url {
  id: ID!
  linkToBinou: String
}

input UrlWhereUniqueInput {
  id: ID
}

input UrlWhereInput {
  AND: [UrlWhereInput!]
  OR: [UrlWhereInput!]
  NOT: [UrlWhereInput!]
  id: IDFilter
  linkToBinou: StringFilter
}

input IDFilter {
  equals: ID
  in: [ID!]
  notIn: [ID!]
  lt: ID
  lte: ID
  gt: ID
  gte: ID
  not: IDFilter
}

input StringFilter {
  equals: String
  in: [String!]
  notIn: [String!]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
  not: NestedStringFilter
}

input NestedStringFilter {
  equals: String
  in: [String!]
  notIn: [String!]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
  not: NestedStringFilter
}

input UrlOrderByInput {
  id: OrderDirection
  linkToBinou: OrderDirection
}

enum OrderDirection {
  asc
  desc
}

input UrlUpdateInput {
  linkToBinou: String
}

input UrlUpdateArgs {
  where: UrlWhereUniqueInput!
  data: UrlUpdateInput!
}

input UrlCreateInput {
  linkToBinou: String
}

type ImageUrl {
  id: ID!
  linkToBinouImage: String
}

input ImageUrlWhereUniqueInput {
  id: ID
}

input ImageUrlWhereInput {
  AND: [ImageUrlWhereInput!]
  OR: [ImageUrlWhereInput!]
  NOT: [ImageUrlWhereInput!]
  id: IDFilter
  linkToBinouImage: StringFilter
}

input ImageUrlOrderByInput {
  id: OrderDirection
  linkToBinouImage: OrderDirection
}

input ImageUrlUpdateInput {
  linkToBinouImage: String
}

input ImageUrlUpdateArgs {
  where: ImageUrlWhereUniqueInput!
  data: ImageUrlUpdateInput!
}

input ImageUrlCreateInput {
  linkToBinouImage: String
}

type History {
  id: ID!
  name: String
  date: DateTime
  user: User
  entity: String
  entityId: String
  operation: String
  before: JSON
  after: JSON
  inputData: JSON
  resolvedData: JSON
  item: ItemData
}

scalar DateTime @specifiedBy(url: "https://datatracker.ietf.org/doc/html/rfc3339#section-5.6")

type ItemData {
  type: String
  plural: String
  entityId: String
}

input HistoryWhereUniqueInput {
  id: ID
}

input HistoryWhereInput {
  AND: [HistoryWhereInput!]
  OR: [HistoryWhereInput!]
  NOT: [HistoryWhereInput!]
  id: IDFilter
  date: DateTimeNullableFilter
  user: UserWhereInput
  entity: StringFilter
  entityId: StringFilter
  operation: StringNullableFilter
}

input DateTimeNullableFilter {
  equals: DateTime
  in: [DateTime!]
  notIn: [DateTime!]
  lt: DateTime
  lte: DateTime
  gt: DateTime
  gte: DateTime
  not: DateTimeNullableFilter
}

input StringNullableFilter {
  equals: String
  in: [String!]
  notIn: [String!]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
  not: StringNullableFilter
}

input HistoryOrderByInput {
  id: OrderDirection
  date: OrderDirection
  entity: OrderDirection
  entityId: OrderDirection
  operation: OrderDirection
}

input HistoryUpdateInput {
  date: DateTime
  user: UserRelateToOneForUpdateInput
  entity: String
  entityId: String
  operation: String
  before: JSON
  after: JSON
  inputData: JSON
  resolvedData: JSON
}

input UserRelateToOneForUpdateInput {
  create: UserCreateInput
  connect: UserWhereUniqueInput
  disconnect: Boolean
}

input HistoryUpdateArgs {
  where: HistoryWhereUniqueInput!
  data: HistoryUpdateInput!
}

input HistoryCreateInput {
  date: DateTime
  user: UserRelateToOneForCreateInput
  entity: String
  entityId: String
  operation: String
  before: JSON
  after: JSON
  inputData: JSON
  resolvedData: JSON
}

input UserRelateToOneForCreateInput {
  create: UserCreateInput
  connect: UserWhereUniqueInput
}

type Historized {
  id: ID!
  name: String
}

input HistorizedWhereUniqueInput {
  id: ID
}

input HistorizedWhereInput {
  AND: [HistorizedWhereInput!]
  OR: [HistorizedWhereInput!]
  NOT: [HistorizedWhereInput!]
  id: IDFilter
  name: StringFilter
}

input HistorizedOrderByInput {
  id: OrderDirection
  name: OrderDirection
}

input HistorizedUpdateInput {
  name: String
}

input HistorizedUpdateArgs {
  where: HistorizedWhereUniqueInput!
  data: HistorizedUpdateInput!
}

input HistorizedCreateInput {
  name: String
}

type TestRiderOTO {
  id: ID!
  name: String
}

input TestRiderOTOWhereUniqueInput {
  id: ID
}

input TestRiderOTOWhereInput {
  AND: [TestRiderOTOWhereInput!]
  OR: [TestRiderOTOWhereInput!]
  NOT: [TestRiderOTOWhereInput!]
  id: IDFilter
  name: StringFilter
}

input TestRiderOTOOrderByInput {
  id: OrderDirection
  name: OrderDirection
}

input TestRiderOTOUpdateInput {
  name: String
}

input TestRiderOTOUpdateArgs {
  where: TestRiderOTOWhereUniqueInput!
  data: TestRiderOTOUpdateInput!
}

input TestRiderOTOCreateInput {
  name: String
}

type TestHorseOTO {
  id: ID!
  name: String
  rider: TestRiderOTO
}

input TestHorseOTOWhereUniqueInput {
  id: ID
}

input TestHorseOTOWhereInput {
  AND: [TestHorseOTOWhereInput!]
  OR: [TestHorseOTOWhereInput!]
  NOT: [TestHorseOTOWhereInput!]
  id: IDFilter
  name: StringFilter
  rider: TestRiderOTOWhereInput
}

input TestHorseOTOOrderByInput {
  id: OrderDirection
  name: OrderDirection
}

input TestHorseOTOUpdateInput {
  name: String
  rider: TestRiderOTORelateToOneForUpdateInput
}

input TestRiderOTORelateToOneForUpdateInput {
  create: TestRiderOTOCreateInput
  connect: TestRiderOTOWhereUniqueInput
  disconnect: Boolean
}

input TestHorseOTOUpdateArgs {
  where: TestHorseOTOWhereUniqueInput!
  data: TestHorseOTOUpdateInput!
}

input TestHorseOTOCreateInput {
  name: String
  rider: TestRiderOTORelateToOneForCreateInput
}

input TestRiderOTORelateToOneForCreateInput {
  create: TestRiderOTOCreateInput
  connect: TestRiderOTOWhereUniqueInput
}

type TestRiderOTM {
  id: ID!
  name: String
  horses(where: TestHorseOTMWhereInput! = {}, orderBy: [TestHorseOTMOrderByInput!]! = [], take: Int, skip: Int! = 0, cursor: TestHorseOTMWhereUniqueInput): [TestHorseOTM!]
  horsesCount(where: TestHorseOTMWhereInput! = {}): Int
}

input TestRiderOTMWhereUniqueInput {
  id: ID
}

input TestRiderOTMWhereInput {
  AND: [TestRiderOTMWhereInput!]
  OR: [TestRiderOTMWhereInput!]
  NOT: [TestRiderOTMWhereInput!]
  id: IDFilter
  name: StringFilter
  horses: TestHorseOTMManyRelationFilter
}

input TestHorseOTMManyRelationFilter {
  every: TestHorseOTMWhereInput
  some: TestHorseOTMWhereInput
  none: TestHorseOTMWhereInput
}

input TestRiderOTMOrderByInput {
  id: OrderDirection
  name: OrderDirection
}

input TestRiderOTMUpdateInput {
  name: String
  horses: TestHorseOTMRelateToManyForUpdateInput
}

input TestHorseOTMRelateToManyForUpdateInput {
  disconnect: [TestHorseOTMWhereUniqueInput!]
  set: [TestHorseOTMWhereUniqueInput!]
  create: [TestHorseOTMCreateInput!]
  connect: [TestHorseOTMWhereUniqueInput!]
}

input TestRiderOTMUpdateArgs {
  where: TestRiderOTMWhereUniqueInput!
  data: TestRiderOTMUpdateInput!
}

input TestRiderOTMCreateInput {
  name: String
  horses: TestHorseOTMRelateToManyForCreateInput
}

input TestHorseOTMRelateToManyForCreateInput {
  create: [TestHorseOTMCreateInput!]
  connect: [TestHorseOTMWhereUniqueInput!]
}

type TestHorseOTM {
  id: ID!
  name: String
}

input TestHorseOTMWhereUniqueInput {
  id: ID
}

input TestHorseOTMWhereInput {
  AND: [TestHorseOTMWhereInput!]
  OR: [TestHorseOTMWhereInput!]
  NOT: [TestHorseOTMWhereInput!]
  id: IDFilter
  name: StringFilter
}

input TestHorseOTMOrderByInput {
  id: OrderDirection
  name: OrderDirection
}

input TestHorseOTMUpdateInput {
  name: String
}

input TestHorseOTMUpdateArgs {
  where: TestHorseOTMWhereUniqueInput!
  data: TestHorseOTMUpdateInput!
}

input TestHorseOTMCreateInput {
  name: String
}

type TestHorseRelationshipRequired {
  id: ID!
  name: String
}

input TestHorseRelationshipRequiredWhereUniqueInput {
  id: ID
}

input TestHorseRelationshipRequiredWhereInput {
  AND: [TestHorseRelationshipRequiredWhereInput!]
  OR: [TestHorseRelationshipRequiredWhereInput!]
  NOT: [TestHorseRelationshipRequiredWhereInput!]
  id: IDFilter
  name: StringFilter
}

input TestHorseRelationshipRequiredOrderByInput {
  id: OrderDirection
  name: OrderDirection
}

input TestHorseRelationshipRequiredUpdateInput {
  name: String
}

input TestHorseRelationshipRequiredUpdateArgs {
  where: TestHorseRelationshipRequiredWhereUniqueInput!
  data: TestHorseRelationshipRequiredUpdateInput!
}

input TestHorseRelationshipRequiredCreateInput {
  name: String
}

type TestRiderRelationshipRequired {
  id: ID!
  name: String
  horse: TestHorseRelationshipRequired
}

input TestRiderRelationshipRequiredWhereUniqueInput {
  id: ID
}

input TestRiderRelationshipRequiredWhereInput {
  AND: [TestRiderRelationshipRequiredWhereInput!]
  OR: [TestRiderRelationshipRequiredWhereInput!]
  NOT: [TestRiderRelationshipRequiredWhereInput!]
  id: IDFilter
  name: StringFilter
  horse: TestHorseRelationshipRequiredWhereInput
}

input TestRiderRelationshipRequiredOrderByInput {
  id: OrderDirection
  name: OrderDirection
}

input TestRiderRelationshipRequiredUpdateInput {
  name: String
  horse: TestHorseRelationshipRequiredRelateToOneForUpdateInput
}

input TestHorseRelationshipRequiredRelateToOneForUpdateInput {
  create: TestHorseRelationshipRequiredCreateInput
  connect: TestHorseRelationshipRequiredWhereUniqueInput
  disconnect: Boolean
}

input TestRiderRelationshipRequiredUpdateArgs {
  where: TestRiderRelationshipRequiredWhereUniqueInput!
  data: TestRiderRelationshipRequiredUpdateInput!
}

input TestRiderRelationshipRequiredCreateInput {
  name: String
  horse: TestHorseRelationshipRequiredRelateToOneForCreateInput
}

input TestHorseRelationshipRequiredRelateToOneForCreateInput {
  create: TestHorseRelationshipRequiredCreateInput
  connect: TestHorseRelationshipRequiredWhereUniqueInput
}

type User {
  id: ID!
  name: String
  email: String
  password: PasswordState
}

type PasswordState {
  isSet: Boolean!
}

input UserWhereUniqueInput {
  id: ID
  email: String
}

input UserWhereInput {
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  NOT: [UserWhereInput!]
  id: IDFilter
  name: StringFilter
  email: StringFilter
}

input UserOrderByInput {
  id: OrderDirection
  name: OrderDirection
  email: OrderDirection
}

input UserUpdateInput {
  name: String
  email: String
  password: String
}

input UserUpdateArgs {
  where: UserWhereUniqueInput!
  data: UserUpdateInput!
}

input UserCreateInput {
  name: String
  email: String
  password: String
}

"""
The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSON @specifiedBy(url: "http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf")

type Mutation {
  createUrl(data: UrlCreateInput!): Url
  createUrls(data: [UrlCreateInput!]!): [Url]
  updateUrl(where: UrlWhereUniqueInput!, data: UrlUpdateInput!): Url
  updateUrls(data: [UrlUpdateArgs!]!): [Url]
  deleteUrl(where: UrlWhereUniqueInput!): Url
  deleteUrls(where: [UrlWhereUniqueInput!]!): [Url]
  createImageUrl(data: ImageUrlCreateInput!): ImageUrl
  createImageUrls(data: [ImageUrlCreateInput!]!): [ImageUrl]
  updateImageUrl(where: ImageUrlWhereUniqueInput!, data: ImageUrlUpdateInput!): ImageUrl
  updateImageUrls(data: [ImageUrlUpdateArgs!]!): [ImageUrl]
  deleteImageUrl(where: ImageUrlWhereUniqueInput!): ImageUrl
  deleteImageUrls(where: [ImageUrlWhereUniqueInput!]!): [ImageUrl]
  createHistory(data: HistoryCreateInput!): History
  createHistories(data: [HistoryCreateInput!]!): [History]
  updateHistory(where: HistoryWhereUniqueInput!, data: HistoryUpdateInput!): History
  updateHistories(data: [HistoryUpdateArgs!]!): [History]
  deleteHistory(where: HistoryWhereUniqueInput!): History
  deleteHistories(where: [HistoryWhereUniqueInput!]!): [History]
  createHistorized(data: HistorizedCreateInput!): Historized
  createHistorizeds(data: [HistorizedCreateInput!]!): [Historized]
  updateHistorized(where: HistorizedWhereUniqueInput!, data: HistorizedUpdateInput!): Historized
  updateHistorizeds(data: [HistorizedUpdateArgs!]!): [Historized]
  deleteHistorized(where: HistorizedWhereUniqueInput!): Historized
  deleteHistorizeds(where: [HistorizedWhereUniqueInput!]!): [Historized]
  createTestRiderOTO(data: TestRiderOTOCreateInput!): TestRiderOTO
  createTestRiderOTOS(data: [TestRiderOTOCreateInput!]!): [TestRiderOTO]
  updateTestRiderOTO(where: TestRiderOTOWhereUniqueInput!, data: TestRiderOTOUpdateInput!): TestRiderOTO
  updateTestRiderOTOS(data: [TestRiderOTOUpdateArgs!]!): [TestRiderOTO]
  deleteTestRiderOTO(where: TestRiderOTOWhereUniqueInput!): TestRiderOTO
  deleteTestRiderOTOS(where: [TestRiderOTOWhereUniqueInput!]!): [TestRiderOTO]
  createTestHorseOTO(data: TestHorseOTOCreateInput!): TestHorseOTO
  createTestHorseOTOS(data: [TestHorseOTOCreateInput!]!): [TestHorseOTO]
  updateTestHorseOTO(where: TestHorseOTOWhereUniqueInput!, data: TestHorseOTOUpdateInput!): TestHorseOTO
  updateTestHorseOTOS(data: [TestHorseOTOUpdateArgs!]!): [TestHorseOTO]
  deleteTestHorseOTO(where: TestHorseOTOWhereUniqueInput!): TestHorseOTO
  deleteTestHorseOTOS(where: [TestHorseOTOWhereUniqueInput!]!): [TestHorseOTO]
  createTestRiderOTM(data: TestRiderOTMCreateInput!): TestRiderOTM
  createTestRiderOTMS(data: [TestRiderOTMCreateInput!]!): [TestRiderOTM]
  updateTestRiderOTM(where: TestRiderOTMWhereUniqueInput!, data: TestRiderOTMUpdateInput!): TestRiderOTM
  updateTestRiderOTMS(data: [TestRiderOTMUpdateArgs!]!): [TestRiderOTM]
  deleteTestRiderOTM(where: TestRiderOTMWhereUniqueInput!): TestRiderOTM
  deleteTestRiderOTMS(where: [TestRiderOTMWhereUniqueInput!]!): [TestRiderOTM]
  createTestHorseOTM(data: TestHorseOTMCreateInput!): TestHorseOTM
  createTestHorseOTMS(data: [TestHorseOTMCreateInput!]!): [TestHorseOTM]
  updateTestHorseOTM(where: TestHorseOTMWhereUniqueInput!, data: TestHorseOTMUpdateInput!): TestHorseOTM
  updateTestHorseOTMS(data: [TestHorseOTMUpdateArgs!]!): [TestHorseOTM]
  deleteTestHorseOTM(where: TestHorseOTMWhereUniqueInput!): TestHorseOTM
  deleteTestHorseOTMS(where: [TestHorseOTMWhereUniqueInput!]!): [TestHorseOTM]
  createTestHorseRelationshipRequired(data: TestHorseRelationshipRequiredCreateInput!): TestHorseRelationshipRequired
  createTestHorseRelationshipRequireds(data: [TestHorseRelationshipRequiredCreateInput!]!): [TestHorseRelationshipRequired]
  updateTestHorseRelationshipRequired(where: TestHorseRelationshipRequiredWhereUniqueInput!, data: TestHorseRelationshipRequiredUpdateInput!): TestHorseRelationshipRequired
  updateTestHorseRelationshipRequireds(data: [TestHorseRelationshipRequiredUpdateArgs!]!): [TestHorseRelationshipRequired]
  deleteTestHorseRelationshipRequired(where: TestHorseRelationshipRequiredWhereUniqueInput!): TestHorseRelationshipRequired
  deleteTestHorseRelationshipRequireds(where: [TestHorseRelationshipRequiredWhereUniqueInput!]!): [TestHorseRelationshipRequired]
  createTestRiderRelationshipRequired(data: TestRiderRelationshipRequiredCreateInput!): TestRiderRelationshipRequired
  createTestRiderRelationshipRequireds(data: [TestRiderRelationshipRequiredCreateInput!]!): [TestRiderRelationshipRequired]
  updateTestRiderRelationshipRequired(where: TestRiderRelationshipRequiredWhereUniqueInput!, data: TestRiderRelationshipRequiredUpdateInput!): TestRiderRelationshipRequired
  updateTestRiderRelationshipRequireds(data: [TestRiderRelationshipRequiredUpdateArgs!]!): [TestRiderRelationshipRequired]
  deleteTestRiderRelationshipRequired(where: TestRiderRelationshipRequiredWhereUniqueInput!): TestRiderRelationshipRequired
  deleteTestRiderRelationshipRequireds(where: [TestRiderRelationshipRequiredWhereUniqueInput!]!): [TestRiderRelationshipRequired]
  createUser(data: UserCreateInput!): User
  createUsers(data: [UserCreateInput!]!): [User]
  updateUser(where: UserWhereUniqueInput!, data: UserUpdateInput!): User
  updateUsers(data: [UserUpdateArgs!]!): [User]
  deleteUser(where: UserWhereUniqueInput!): User
  deleteUsers(where: [UserWhereUniqueInput!]!): [User]
}

type Query {
  urls(where: UrlWhereInput! = {}, orderBy: [UrlOrderByInput!]! = [], take: Int, skip: Int! = 0, cursor: UrlWhereUniqueInput): [Url!]
  url(where: UrlWhereUniqueInput!): Url
  urlsCount(where: UrlWhereInput! = {}): Int
  imageUrls(where: ImageUrlWhereInput! = {}, orderBy: [ImageUrlOrderByInput!]! = [], take: Int, skip: Int! = 0, cursor: ImageUrlWhereUniqueInput): [ImageUrl!]
  imageUrl(where: ImageUrlWhereUniqueInput!): ImageUrl
  imageUrlsCount(where: ImageUrlWhereInput! = {}): Int
  histories(where: HistoryWhereInput! = {}, orderBy: [HistoryOrderByInput!]! = [], take: Int, skip: Int! = 0, cursor: HistoryWhereUniqueInput): [History!]
  history(where: HistoryWhereUniqueInput!): History
  historiesCount(where: HistoryWhereInput! = {}): Int
  historizeds(where: HistorizedWhereInput! = {}, orderBy: [HistorizedOrderByInput!]! = [], take: Int, skip: Int! = 0, cursor: HistorizedWhereUniqueInput): [Historized!]
  historized(where: HistorizedWhereUniqueInput!): Historized
  historizedsCount(where: HistorizedWhereInput! = {}): Int
  testRiderOTOS(where: TestRiderOTOWhereInput! = {}, orderBy: [TestRiderOTOOrderByInput!]! = [], take: Int, skip: Int! = 0, cursor: TestRiderOTOWhereUniqueInput): [TestRiderOTO!]
  testRiderOTO(where: TestRiderOTOWhereUniqueInput!): TestRiderOTO
  testRiderOTOSCount(where: TestRiderOTOWhereInput! = {}): Int
  testHorseOTOS(where: TestHorseOTOWhereInput! = {}, orderBy: [TestHorseOTOOrderByInput!]! = [], take: Int, skip: Int! = 0, cursor: TestHorseOTOWhereUniqueInput): [TestHorseOTO!]
  testHorseOTO(where: TestHorseOTOWhereUniqueInput!): TestHorseOTO
  testHorseOTOSCount(where: TestHorseOTOWhereInput! = {}): Int
  testRiderOTMS(where: TestRiderOTMWhereInput! = {}, orderBy: [TestRiderOTMOrderByInput!]! = [], take: Int, skip: Int! = 0, cursor: TestRiderOTMWhereUniqueInput): [TestRiderOTM!]
  testRiderOTM(where: TestRiderOTMWhereUniqueInput!): TestRiderOTM
  testRiderOTMSCount(where: TestRiderOTMWhereInput! = {}): Int
  testHorseOTMS(where: TestHorseOTMWhereInput! = {}, orderBy: [TestHorseOTMOrderByInput!]! = [], take: Int, skip: Int! = 0, cursor: TestHorseOTMWhereUniqueInput): [TestHorseOTM!]
  testHorseOTM(where: TestHorseOTMWhereUniqueInput!): TestHorseOTM
  testHorseOTMSCount(where: TestHorseOTMWhereInput! = {}): Int
  testHorseRelationshipRequireds(where: TestHorseRelationshipRequiredWhereInput! = {}, orderBy: [TestHorseRelationshipRequiredOrderByInput!]! = [], take: Int, skip: Int! = 0, cursor: TestHorseRelationshipRequiredWhereUniqueInput): [TestHorseRelationshipRequired!]
  testHorseRelationshipRequired(where: TestHorseRelationshipRequiredWhereUniqueInput!): TestHorseRelationshipRequired
  testHorseRelationshipRequiredsCount(where: TestHorseRelationshipRequiredWhereInput! = {}): Int
  testRiderRelationshipRequireds(where: TestRiderRelationshipRequiredWhereInput! = {}, orderBy: [TestRiderRelationshipRequiredOrderByInput!]! = [], take: Int, skip: Int! = 0, cursor: TestRiderRelationshipRequiredWhereUniqueInput): [TestRiderRelationshipRequired!]
  testRiderRelationshipRequired(where: TestRiderRelationshipRequiredWhereUniqueInput!): TestRiderRelationshipRequired
  testRiderRelationshipRequiredsCount(where: TestRiderRelationshipRequiredWhereInput! = {}): Int
  users(where: UserWhereInput! = {}, orderBy: [UserOrderByInput!]! = [], take: Int, skip: Int! = 0, cursor: UserWhereUniqueInput): [User!]
  user(where: UserWhereUniqueInput!): User
  usersCount(where: UserWhereInput! = {}): Int
  keystone: KeystoneMeta!
}

type KeystoneMeta {
  adminMeta: KeystoneAdminMeta!
}

type KeystoneAdminMeta {
  lists: [KeystoneAdminUIListMeta!]!
  list(key: String!): KeystoneAdminUIListMeta
}

type KeystoneAdminUIListMeta {
  key: String!
  itemQueryName: String!
  listQueryName: String!
  hideCreate: Boolean!
  hideDelete: Boolean!
  path: String!
  label: String!
  singular: String!
  plural: String!
  description: String
  initialColumns: [String!]!
  pageSize: Int!
  labelField: String!
  fields: [KeystoneAdminUIFieldMeta!]!
  groups: [KeystoneAdminUIFieldGroupMeta!]!
  initialSort: KeystoneAdminUISort
  isHidden: Boolean!
  isSingleton: Boolean!
}

type KeystoneAdminUIFieldMeta {
  path: String!
  label: String!
  description: String
  isOrderable: Boolean!
  isFilterable: Boolean!
  isNonNull: [KeystoneAdminUIFieldMetaIsNonNull!]
  fieldMeta: JSON
  viewsIndex: Int!
  customViewsIndex: Int
  createView: KeystoneAdminUIFieldMetaCreateView!
  listView: KeystoneAdminUIFieldMetaListView!
  itemView(id: ID): KeystoneAdminUIFieldMetaItemView
  search: QueryMode
}

enum KeystoneAdminUIFieldMetaIsNonNull {
  read
  create
  update
}

type KeystoneAdminUIFieldMetaCreateView {
  fieldMode: KeystoneAdminUIFieldMetaCreateViewFieldMode!
}

enum KeystoneAdminUIFieldMetaCreateViewFieldMode {
  edit
  hidden
}

type KeystoneAdminUIFieldMetaListView {
  fieldMode: KeystoneAdminUIFieldMetaListViewFieldMode!
}

enum KeystoneAdminUIFieldMetaListViewFieldMode {
  read
  hidden
}

type KeystoneAdminUIFieldMetaItemView {
  fieldMode: KeystoneAdminUIFieldMetaItemViewFieldMode
  fieldPosition: KeystoneAdminUIFieldMetaItemViewFieldPosition
}

enum KeystoneAdminUIFieldMetaItemViewFieldMode {
  edit
  read
  hidden
}

enum KeystoneAdminUIFieldMetaItemViewFieldPosition {
  form
  sidebar
}

enum QueryMode {
  default
  insensitive
}

type KeystoneAdminUIFieldGroupMeta {
  label: String!
  description: String
  fields: [KeystoneAdminUIFieldMeta!]!
}

type KeystoneAdminUISort {
  field: String!
  direction: KeystoneAdminUISortDirection!
}

enum KeystoneAdminUISortDirection {
  ASC
  DESC
}
